
#include <string>
#include <vector>
#include <cstdint>
#include <unordered_set>

#include "ansi.h"
#include "bignum/big.h"
#include "base/logging.h"

using namespace std;

// TODO: to big-overloads.h or whatever

// TODO modifying operators
// TODO spaceship
// TODO << >> | & ^

inline BigInt operator ""_b(const char *s) {
  return BigInt(s);
}

inline BigInt operator *(const BigInt &a, const BigInt &b) {
  return BigInt::Times(a, b);
}

inline BigInt operator +(const BigInt &a, const BigInt &b) {
  return BigInt::Plus(a, b);
}

inline BigInt operator /(const BigInt &a, const BigInt &b) {
  return BigInt::Div(a, b);
}

inline BigInt operator %(const BigInt &a, const BigInt &b) {
  return BigInt::Mod(a, b);
}

inline BigInt operator -(const BigInt &a, const BigInt &b) {
  return BigInt::Minus(a, b);
}

inline BigInt operator -(const BigInt &a) {
  return BigInt::Negate(a);
}

inline BigInt operator +(const BigInt &a) {
  return a;
}

inline bool operator <(const BigInt &a, const BigInt &b) {
  return BigInt::Less(a, b);
}

inline bool operator <=(const BigInt &a, const BigInt &b) {
  return BigInt::LessEq(a, b);
}

inline bool operator >(const BigInt &a, const BigInt &b) {
  return BigInt::Greater(a, b);
}

inline bool operator >=(const BigInt &a, const BigInt &b) {
  return BigInt::GreaterEq(a, b);
}

inline bool operator ==(const BigInt &a, const BigInt &b) {
  return BigInt::Eq(a, b);
}

using Sol = std::pair<BigInt, BigInt>;


// For sol = (x, y), compute k such that n * x^2 + k = y^2.
static BigInt Error(const BigInt &n, const Sol &sol) {
  const auto &[x, y] = sol;
  return y * y - n * x * x;
}

static Sol CombineSelf(const BigInt &n, const Sol &sol) {
  const auto &[x, y] = sol;
  return make_pair(
      2_b * x * y,
      y * y + n * x * x);
  // and also the degenerate (0, y^2 - nx^2)
}

static std::pair<Sol, Sol> Combine(
    const BigInt &n, const Sol &sol1, const Sol &sol2) {
  const auto &[a, b] = sol1;
  const auto &[c, d] = sol2;

  return
    make_pair(
        make_pair(b * c + a * d, b * d + n * a * c),
        make_pair(b * c - a * d, b * d - n * a * c));
}

struct HashSol {
  size_t operator ()(const Sol &sol) const {
    return (size_t)BigInt::LowWord(sol.first + sol.second);
  }
};

struct EqSol {
  bool operator ()(const Sol &a, const Sol &b) const {
    return a.first == b.first && a.second == b.second;
  }
};

int main(int argc, char **argv) {
  ANSI::Init();

  // two equations
  // 222121 x^2 + 1 = y_a^2
  // 360721 x^2 + 1 = y_h^2
  // (y_a is called a in the square; y_h is called h. but we are going
  // to use a,b,c for other coefficients here.)

  const BigInt n_a = 222121_b;
  const BigInt n_h = 360721_b;

  /*
  const Sol sol_a0 =
    make_pair(8842189948832648717976105224334566231789600792803642348336846827782225806006855280976217289118615305107682054895297594374602589755796972496322910297363322405874424178328332781536562552307657505453833599478503983455352282819585114679974738910948956926775461863362701876119522363590230122779441071446571252735232045259462920927627602773872009296099583607374282385807997919609229375157099719827845573764419215460756307117338718705124111599350778355070690163390358271136546610163464791543734856676842230966901796548189022153685361283212100818504956402828918077049598784514157937329970721134766921855778777097018434984093865266237449423446137852415940785748186382900083801424749832395073802747373107275339458916177922982623150814648914210247907914320688212459625265454072461678943182520613760660711242184871092934051875746555178887920026779546814493124227951855861559722332256073075000637308442102258111126057878132592612075567003501660768306324641643851953872905233068817472148281418992759748342510080_b,
              4167298888890582095707942644915909558693314338697460802361027516877389482010683040734334685893379069518445325738888043591720130533090476155218905963353853138415389805842948191472397753805538136043353419743732439776651789419466216397061517616908164550469414914222796669598174932940417079930866612420109453717999380832147081416783219050603157443451274858295790645852469148942430369467476733682592406931237359920948068211055237872219528168235894378054900825814402581104144526649820275635441124896092749338898851010534461783770286817451522331727606529272875580972170116823257246119045270884996675133123042535167048097824065361852817095182387885561517191950666918569584524337401505215087336893548454054178142397694042797084464051758314470302325664351167823711913554602094558720922988601091194640067523138656436344755648112597091057443163587216452729560253513930017234722189432729945326245909311513386404346667972770519088392806077797566373789678779978979570023446023484159626315711113877814558678479667201_b);
  */
  const Sol sol_a0 =
    make_pair(96853990143729182446466254903787102920420186066745135266595909679523238492820905098594426380259780074224586852201498992449275127756378129855820172958584294747666448702649536007880590904630402994485054414777494200716316411350928848627022864018323664548200672490871343394924009459667481509707703598930232145417695483619768820532418380893489621163234820873999155059853985917579838562873820424199495555730452754055968329456327571681829182817764194271946670769735346243288252413916542521030793275016960_b,
              45647009151151305718708252078329478619159688396560344940484846739545404737863346364814575382380658468268696696162077346578703916050375366743990587977745934350267627720790556553334680620537062793215771183142869525305229082597324857232212169256203590974623367552076861467765584622698250583658967988921977292909237331892140561912612147974391374706186555174904116425103638903793323393015436354152507544138006929555916470598773073491241252241089212693998884441309720519067489536318638130578697131025203199_b);

  CHECK(Error(n_a, sol_a0) == 1_b);

  const Sol sol_h0 =
    make_pair(5254301467178253668063501573805488115701470062129148344048204657019748885380657942526435850589822056436907162208858662833748764291164063392849591565232182340896344102417561460498588341287763598974028219631368919894791141180699352614842162329575092178804714936187264001803984435149307802237910897195756701561689733829416441654000294332579338938600777476665373690729282455769460482322102437685615931720435571771362615173743048328285921760676802224631583102137529433447859249096920912083501391265263092551585295016322744236018859511648734714069848447775860243716078071973487185423849887186837594810420676451477817334917442425724234656945231269179119186700637627642532511974556138751986944397915640033290288664241890733655443663188699611507335767790934980909769231545567661414370796993132434555657909168192875390617801233376652983464964576564440125236085759750607806749224929539111304657072598148941302658707149037639442679980053501547520718161071834317467291327489266555022779213264638058690142715120_b,
              3155736260680638626215586515224779475000982538318510234796596948969542279640527333764830931669758997548264003306978761631985610163542280769957617791837115815855505466192424155483747195334026528686100467671456903838445918904622247229490490143150205748045220079365084818251874000588893203069462517365771614948335859034465574562253629688393366532513342848079469578491642318761744360133449340864599791431253295837903633977372300833275627599528361343594279999123827422243803042839623732782710017503150424671269804820044584384922764477211533947638524985602275604505195848101327992205477251957539278637282982381170957580513664760124760363535719750512488336024599849383281905125902008900085015792063893406749523426160808130369628761209934170648229913920676290078798350463180533834821461892201220681643823782682294011883387286116223752801467866509139817280697848323355423553433987427070952556267278422608907045802820393525018738409778215962756148887404031077236716404130655643413294151356469733756144336771201_b);

  BigInt err1 = Error(n_h, sol_h0);
  CHECK(err1 == 1_b) << err1.ToString();


  // First let's try using Brahmagupta's identity
  // Sol sol_a = sol_a0;
  // Sol sol_h = sol_h0;

  std::unordered_set<Sol, HashSol, EqSol> asols, hsols;
  asols.insert(sol_a0);
  hsols.insert(sol_h0);

  std::unordered_set<Sol, HashSol, EqSol> aexpanded, hexpanded;

  // As an invariant, anything in asols is a solution for a;
  // and bsols for h.
  // n_a * x_a^2 + 1 = y_a^2
  // n_h * x_h^2 + 1 = y_h^2
  for (;;) {
    for (const Sol &sol_h : hsols) {
      BigInt err1 = Error(n_h, sol_h);
      CHECK(err1 == 1_b) << err1.ToString();
    }
    for (const Sol &sol_a : asols) {
      BigInt err2 = Error(n_a, sol_a);
      CHECK(err2 == 1_b) << err2.ToString();
    }

    // Find best.
    BigInt best = -1_b;
    const Sol *bhs = nullptr;
    const Sol *bas = nullptr;
    for (const Sol &sol_h : hsols) {
      bool hsol_new = !hexpanded.contains(sol_h);
      for (const Sol &sol_a : asols) {
        if (hsol_new || !aexpanded.contains(sol_a)) {
          BigInt diff = BigInt::Abs(sol_h.first - sol_a.first);
          if (best < 0_b || diff < best) {
            best = diff;
            bhs = &sol_h;
            bas = &sol_a;
          }
        }
      }
    }
    printf("%dx%d sols. best diff %d digits\n",
           (int)hsols.size(), (int)asols.size(),
           (int)best.ToString().size());
    if (bhs == nullptr || bas == nullptr) {
      CHECK(false) << "Unexpected for this to saturate...\n";
    }

    // The defect here is that we need x_a = x_h. What we can do
    // is find a new solution for a or h, with the hopes that
    // they are closer together.
    hexpanded.insert(*bhs);
    aexpanded.insert(*bas);

    Sol sol_h_self = CombineSelf(n_h, *bhs);
    Sol sol_a_self = CombineSelf(n_a, *bas);

    CHECK(Error(n_h, sol_h_self) == 1_b);
    CHECK(Error(n_a, sol_a_self) == 1_b);
    hsols.insert(sol_h_self);
    asols.insert(sol_a_self);
  }

  printf(AGREEN("OK") " :)\n");
  return 0;
}
