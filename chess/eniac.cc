
// Contributed by Jered Wierzbicki, Jonathan Stray.
// see https://github.com/jeredw/eniac-chess and LICENSE for more details.

// Simple standalone client for playing against ENIAC chess
#include <algorithm>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <utility>
#include <vector>
#include <cassert>
#include <cstring>

// eniac_chess_move() returns ENIAC Chess's move in the position given by fen.
// Assumes fen is a valid position in Forsyth-Edwards notation with ENIAC to
// play. The returned move will use long algebraic notation e.g. "a1b1". If
// there is an error or ENIAC resigns, return the empty string.
std::string eniac_chess_move(const std::string& fen);

namespace {
// Generated by chasm.py, see Makefile.
#include "eniac-data.cc"

// Copied from chsim/vm.cc to make redistribution easier.
struct VM {
  int status;
  int error;

  // Fetch state
  int pc;
  int old_pc;
  int ir[6];
  int ir_index;
  // Register file
  int a;
  int b;
  int c;
  int d;
  int e;
  // Load store scratch
  int f;
  int g;
  int h;
  int i;
  int j;
  // Memory
  int mem[15][5];
  // ROM, essentially
  int function_table[400][6];
};

enum {
  HALT = 0x01,
  BREAK = 0x02,
  IO_READ = 0x04,
  IO_PRINT = 0x08,
};

enum {
  ERROR_A_BOUNDS = 1<<0,
  ERROR_B_BOUNDS = 1<<1,
  ERROR_C_BOUNDS = 1<<2,
  ERROR_D_BOUNDS = 1<<3,
  ERROR_E_BOUNDS = 1<<4,
  ERROR_F_BOUNDS = 1<<5,
  ERROR_G_BOUNDS = 1<<6,
  ERROR_H_BOUNDS = 1<<7,
  ERROR_I_BOUNDS = 1<<8,
  ERROR_J_BOUNDS = 1<<9,
  ERROR_PC_BOUNDS = 1<<10,
  ERROR_RR_BOUNDS = 1<<11,
  ERROR_IR_BOUNDS = 1<<12,
  ERROR_MEM_BOUNDS = 1<<13, // addr in lower bits
  ERROR_PC_WRAPPED = 1<<14,
  ERROR_OPERAND_MISALIGNED = 1<<15,
  ERROR_ILLEGAL_BANK = 1<<16,
  ERROR_ILLEGAL_ACC = 1<<17,
  ERROR_ILLEGAL_FTL = 1<<18,
  ERROR_ILLEGAL_ADDRESS = 1<<19,
  ERROR_ILLEGAL_OPCODE = 1<<20,
};

// Reset state for a new VM instance
void init(VM* vm) {
  vm->status = 0;
  vm->error = 0;
  vm->pc = 100;
  vm->old_pc = 0;
  for (int i = 0; i < 6; i++)
    vm->ir[i] = 0;
  vm->ir_index = 6;
  vm->a = 0;
  vm->b = 0;
  vm->c = 0;
  vm->d = 0;
  vm->e = 0;
  vm->f = 0;
  vm->g = 0;
  vm->h = 0;
  vm->i = 0;
  vm->j = 0;
  for (int i = 0; i < 15; i++)
    for (int j = 0; j < 5; j++)
      vm->mem[i][j] = 0;
  for (int i = 0; i < 100; i++)
    for (int j = 0; j < 6; j++)
      vm->function_table[i][j] = 0;
  for (int i = 100, k = 0; i < 400; i++) {
    for (int j = 0; j < 6; j++, k++) {
      vm->function_table[i][j] = program[k];
    }
  }
}

void check_register_bounds(VM* vm) {
#define CHECK(code, condition) if (!(condition)) vm->error |= code
  CHECK(ERROR_A_BOUNDS, vm->a >= -100 && vm->a < 100);
  CHECK(ERROR_B_BOUNDS, vm->b >= 0 && vm->b < 100);
  CHECK(ERROR_C_BOUNDS, vm->c >= 0 && vm->c < 100);
  CHECK(ERROR_D_BOUNDS, vm->d >= 0 && vm->d < 100);
  CHECK(ERROR_E_BOUNDS, vm->e >= 0 && vm->e < 100);
  CHECK(ERROR_F_BOUNDS, vm->f >= -100 && vm->f < 100);
  CHECK(ERROR_G_BOUNDS, vm->g >= 0 && vm->g < 100);
  CHECK(ERROR_H_BOUNDS, vm->h >= 0 && vm->h < 100);
  CHECK(ERROR_I_BOUNDS, vm->i >= 0 && vm->i < 100);
  CHECK(ERROR_J_BOUNDS, vm->j >= 0 && vm->j < 100);
  CHECK(ERROR_PC_BOUNDS, vm->pc >= 100 && vm->pc < 400);
  CHECK(ERROR_RR_BOUNDS, vm->old_pc == 0 || (vm->old_pc >= 100 && vm->old_pc < 400));
  CHECK(ERROR_IR_BOUNDS, vm->ir_index >= 0 && vm->ir_index <= 6);
  for (int i = 0; i < 15; i++) {
    for (int j = 0; j < 5; j++) {
      // First word of each memory accumulator can be negative; this is visible
      // through loadacc but not word mov.
      int min_value = j == 0 ? -100 : 0;
      if (!(vm->mem[i][j] >= min_value && vm->mem[i][j] < 100)) {
        vm->error = ERROR_MEM_BOUNDS | (5*i + j);
        break;
      }
    }
  }
  if (vm->error) vm->status |= HALT;
#undef CHECK
}

int drop_sign(int a) {
  if (a >= 0) {
    return a;
  }
  return a + 100;  // e.g. M99 (-1) -> P99
}

int copy_sign(int f, int a) {
  int digits = drop_sign(a);
  if (f >= 0) {
    return digits;
  }
  return digits - 100;  // e.g. P99 -> -1
}

void swap_dropping_sign(int& a, int& x) {
  int tmp = drop_sign(a);
  a = x;
  x = tmp;
}

int consume_ir(VM* vm) {
  if (vm->ir_index == 6) {
    vm->ir_index = vm->pc >= 300 ? 1 : 0;
    std::copy(vm->function_table[vm->pc], vm->function_table[vm->pc] + 6, vm->ir);
    vm->pc++;
    if (vm->pc == 200 || vm->pc == 300) {
      vm->error |= ERROR_PC_WRAPPED;
      vm->status |= HALT;
      return 95; // halt
    }
  }
  return vm->ir[vm->ir_index++];
}

int consume_operand(VM* vm) {
  if (vm->ir_index == 6) {
    vm->error |= ERROR_OPERAND_MISALIGNED;
    vm->status |= HALT;
    return 95; // halt
  }
  vm->ir[vm->ir_index]++;
  int sled_start = 6;
  while (sled_start > 0 && vm->ir[sled_start-1] == 99) {
    sled_start--;
  }
  for (int i = vm->ir_index; i < 6; i++) {
    if (vm->ir[i] == 100) {
      vm->ir[i] = 0;
      // Do not carry into sled
      if (i < sled_start-1) {
        vm->ir[i+1]++;
      }
    }
  }
  return vm->ir[vm->ir_index++];
}

int consume_near_address(VM* vm) {
  int target = consume_operand(vm);
  return 100 * (vm->pc / 100) + target;
}

int consume_far_address(VM* vm) {
  int target = consume_operand(vm);
  int bank = consume_ir(vm);
  if (!(bank == 9 || bank == 90 || bank == 99)) {
    vm->error |= ERROR_ILLEGAL_BANK;
    vm->status |= HALT;
    return vm->pc;
  }
  if (bank == 9)
    return 100 + target;
  else if (bank == 90)
    return 200 + target;
  else
    return 300 + target;
}

inline void copy_mem_to_ls(VM *vm, int acc) {
  vm->f = vm->mem[acc][0];
  vm->g = vm->mem[acc][1];
  vm->h = vm->mem[acc][2];
  vm->i = vm->mem[acc][3];
  vm->j = vm->mem[acc][4];
}

inline void copy_ls_to_mem(VM *vm, int acc) {
  vm->mem[acc][0] = vm->f;
  vm->mem[acc][1] = vm->g;
  vm->mem[acc][2] = vm->h;
  vm->mem[acc][3] = vm->i;
  vm->mem[acc][4] = vm->j;
}

void update_bank(VM* vm) {
  int bank = (vm->pc / 100) % 10;
  // Signs of a18, a19, and a20 reflect the current ft bank
  vm->mem[12][0] = copy_sign(bank == 1 ? +1 : -1, vm->mem[12][0]);
  vm->mem[13][0] = copy_sign(bank == 2 ? +1 : -1, vm->mem[13][0]);
  vm->mem[14][0] = copy_sign(bank == 3 ? +1 : -1, vm->mem[14][0]);
}

void step_one_instruction(VM* vm) {
  if (vm->status & HALT) return;
  int opcode = consume_ir(vm);
  switch (opcode) {
    case 0: // clrall
      vm->a = 0;
      vm->b = 0;
      vm->c = 0;
      vm->d = 0;
      vm->e = 0;
      break;
    case 1: // swap A, B
      swap_dropping_sign(vm->a, vm->b);
      break;
    case 2: // swap A, C
      swap_dropping_sign(vm->a, vm->c);
      break;
    case 3: // swap A, D
      swap_dropping_sign(vm->a, vm->d);
      break;
    case 4: // swap A, E
      swap_dropping_sign(vm->a, vm->e);
      break;
    case 10: // loadacc A
      if (!(0 <= vm->a && vm->a < 15)) {
        vm->error |= ERROR_ILLEGAL_ACC;
        vm->status |= HALT;
        break;
      }
      copy_mem_to_ls(vm, vm->a);
      break;
    case 11: // storeacc A
      if (!(0 <= vm->a && vm->a < 15)) {
        vm->error |= ERROR_ILLEGAL_ACC;
        vm->status |= HALT;
        break;
      }
      vm->f = copy_sign(vm->mem[vm->a][0], vm->f);
      copy_ls_to_mem(vm, vm->a);
      break;
    case 12: // swapall
      std::swap(vm->a, vm->f);
      std::swap(vm->b, vm->g);
      std::swap(vm->c, vm->h);
      std::swap(vm->d, vm->i);
      std::swap(vm->e, vm->j);
      break;
    case 14: { // ftl A
      int offset = drop_sign(vm->a);
      if (!(6 <= offset && offset <= 99)) {
        vm->error |= ERROR_ILLEGAL_FTL;
        vm->status |= HALT;
        break;
      }
      vm->a = vm->function_table[300 + offset][0];
      break;
    }
    case 20: // mov B, A
      vm->a = vm->b;
      break;
    case 21: // mov C, A
      vm->a = vm->c;
      break;
    case 22: // mov D, A
      vm->a = vm->d;
      break;
    case 23: // mov E, A
      vm->a = vm->e;
      break;
    case 34: // mov F, A
      vm->a = drop_sign(vm->f);
      break;
    case 30: // mov G, A
      vm->a = vm->g;
      break;
    case 31: // mov H, A
      vm->a = vm->h;
      break;
    case 32: // mov I, A
      vm->a = vm->i;
      break;
    case 33: // mov J, A
      vm->a = vm->j;
      break;
    case 40: // mov imm, A
      vm->a = consume_operand(vm);
      break;
    case 41: { // mov [B], A
      if (vm->b < 0 || vm->b >= 75) {
        vm->error |= ERROR_ILLEGAL_ADDRESS;
        vm->status |= HALT;
        break;
      }
      int acc = vm->b / 5;
      int word = vm->b % 5;
      copy_mem_to_ls(vm, acc);
      switch (word) {
        case 0: vm->a = drop_sign(vm->f); break;
        case 1: vm->a = vm->g; break;
        case 2: vm->a = vm->h; break;
        case 3: vm->a = vm->i; break;
        case 4: vm->a = vm->j; break;
      }
      break;
    }
    case 42: { // mov A, [B]
      if (vm->b < 0 || vm->b >= 75) {
        vm->error |= ERROR_ILLEGAL_ADDRESS;
        vm->status |= HALT;
        break;
      }
      int acc = vm->b / 5;
      int word = vm->b % 5;
      copy_mem_to_ls(vm, acc);
      switch (word) {
        case 0: vm->f = copy_sign(vm->f, vm->a); break;
        case 1: vm->g = drop_sign(vm->a); break;
        case 2: vm->h = drop_sign(vm->a); break;
        case 3: vm->i = drop_sign(vm->a); break;
        case 4: vm->j = drop_sign(vm->a); break;
      }
      copy_ls_to_mem(vm, acc);
      break;
    }
    case 43: // lodig A
      if (vm->a >= 0) {
        vm->a = vm->a % 10;
      } else {
        // lodig M99 = M09 (-91)
        int digits = 100 + vm->a;
        int tens_digit = digits % 10; // M99 (-1) -> 9
        vm->a = tens_digit - 100; // 9 -> M09 (-91)
      }
      break;
    case 44: // swapdig A
      if (vm->a >= 0) {
        int tens_digit = vm->a / 10;
        int ones_digit = vm->a % 10;
        vm->a = 10 * ones_digit + tens_digit;
      } else {
        // swapdig M98 = M89
        int digits = 100 + vm->a; // M98 (-2) -> 98
        int tens_digit = digits / 10;
        int ones_digit = digits % 10;
        int swapped_digits = 10 * ones_digit + tens_digit;
        vm->a = swapped_digits - 100; // 89 -> M89 (-11)
      }
      break;
    case 52: // inc A
      vm->a++;
      if (vm->a == 100)
        vm->a = -100;
      break;
    case 53: // dec A
      vm->a--;
      if (vm->a == -101)
        vm->a = 99;
      break;
    case 54: // flipn
      if (vm->a < 0)
        vm->a += 100;
      else
        vm->a -= 100;
      break;
    case 70: // add D,A
      vm->a += vm->d;
      if (vm->a >= 100)
        vm->a -= 200;
      break;
    case 71: // add imm,A
      vm->a += consume_operand(vm);
      if (vm->a >= 100)
        vm->a -= 200;
      break;
    case 72: // sub D,A
      vm->a -= vm->d;
      if (vm->a >= 100)
        vm->a -= 200;
      if (vm->a < -100)
        vm->a += 200;
      break;
    case 73: { // jmp
      vm->pc = consume_near_address(vm);
      vm->ir_index = 6;
      break;
    }
    case 74: { // jmp far
      vm->pc = consume_far_address(vm);
      update_bank(vm);
      vm->ir_index = 6;
      break;
    }
    case 80: { // jn
      int taken_pc = consume_near_address(vm);
      if (vm->a < 0) {
        vm->pc = taken_pc;
        vm->ir_index = 6;
      }
      break;
    }
    case 81: { // jz
      int taken_pc = consume_near_address(vm);
      if (vm->a == 0 || vm->a == -100) {
        vm->pc = taken_pc;
        vm->ir_index = 6;
      }
      break;
    }
    case 82: { // jil
      int taken_pc = consume_near_address(vm);
      int digits = vm->a < 0 ? 100 + vm->a : vm->a;
      int d1 = digits % 10;
      int d2 = (digits / 10) % 10;
      if (d1 == 0 || d1 == 9 || d2 == 0 || d2 == 9) {
        vm->pc = taken_pc;
        vm->ir_index = 6;
      }
      break;
    }
    case 84: { // jsr
      vm->old_pc = vm->pc;
      assert(vm->ir_index <= 5);
      vm->pc = consume_far_address(vm);
      update_bank(vm);
      vm->ir_index = 6;
      break;
    }
    case 85: // ret
      vm->pc = vm->old_pc;
      update_bank(vm);
      vm->old_pc = 0;
      vm->ir_index = 6;
      break;
    case 90: // clr A
      vm->a = 0;
      break;
    case 91: // read
      vm->status |= IO_READ;
      break;
    case 92: // print
      vm->status |= IO_PRINT;
      break;
    case 94: // brk
      vm->status |= BREAK;
      break;
    case 95: // halt
      vm->status |= HALT;
      break;
    case 99: // sled
      break;
    default: // illegal opcode
      vm->error |= ERROR_ILLEGAL_OPCODE;
      vm->status |= HALT;
      break;
  }
  check_register_bounds(vm);
}

typedef std::pair<int, int> Card;
typedef std::vector<Card> Deck;
struct Position {
  char board[10][10];
  char to_play;
};

bool parse_fen(const std::string& fen, Position& position) {
  int i = 0, rook = 0;
  for (int y = 8; y >= 1; y--) {
    for (int x = 1; x <= 8; i++) {
      if (fen[i] >= '1' && fen[i] <= '8') {
        for (int n = fen[i] - '0'; n > 0; n--)
          position.board[y][x++] = '.';
      } else if (fen[i] == 'R' && rook++ == 2) {
        return false;
      } else if (!strchr("RKPNBQrkpnbq", fen[i])) {
        return false;
      } else {
        position.board[y][x++] = fen[i];
      }
    }
    char delim = fen[i++];
    if (y > 1 && delim != '/') return false;
    if (y == 1 && delim != ' ') return false;
  }
  if (fen[i] != 'w' && fen[i] != 'b') return false;
  position.to_play = fen[i];
  return true;
}

Deck convert_position_to_deck(const Position& position) {
  int memory[150] = {0};
# define SET_MEMORY(base, hi, low) \
  memory[base] = hi;\
  memory[base+1] = low;
  const int wking = 2 * 32;
  const int bking = 2 * 33;
  const int wrook = 2 * 34;
  const int fromp = 2 * 36;
  const int mscore = 2 * 37;
  const int depth = 2 * 38;
  const int best_score = 2 * 45;
  const int beta = 2 * 69;
  int rook = 0;
  for (int y = 1; y <= 8; y++) {
    int j = 8 * (y - 1);
    for (int x = 1; x <= 8; x++) {
      switch (position.board[y][x]) {
        case 'R':
          memory[j++] = 1;
          SET_MEMORY(wrook + 2*rook, y, x);
          rook++;
          break;
        case 'K':
          memory[j++] = 1;
          SET_MEMORY(wking, y, x);
          break;
        case 'P': memory[j++] = 2; break;
        case 'N': memory[j++] = 3; break;
        case 'B': memory[j++] = 4; break;
        case 'Q': memory[j++] = 5; break;
        case 'r': memory[j++] = 1; break;
        case 'k':
          memory[j++] = 1;
          SET_MEMORY(bking, y, x);
          break;
        case 'p': memory[j++] = 6; break;
        case 'n': memory[j++] = 7; break;
        case 'b': memory[j++] = 8; break;
        case 'q': memory[j++] = 9; break;
        default: memory[j++] = 0; break;
      }
    }
  }
  if (position.to_play == 'w') {
    SET_MEMORY(fromp, 0, 0);
    SET_MEMORY(best_score, 0, 0);
  } else {
    SET_MEMORY(fromp, 1, 0);
    SET_MEMORY(best_score, 9, 9);
  }
  SET_MEMORY(mscore, 5, 0);
  SET_MEMORY(beta, 9, 9);
  SET_MEMORY(depth, 0, 1);
# undef SET_MEMORY

  Deck deck;
  for (int i = 0; i < 75; i++) {
    deck.push_back({i, 10 * memory[2*i] + memory[2*i + 1]});
  }
  deck.push_back({99, 0});
  return deck;
}

std::string convert_move_to_lan(const Position& position, int from, int to) {
  int from_y = from / 10;
  int from_x = from % 10;
  int to_y = to / 10;
  int to_x = to % 10;
  if (from_y >= 1 && from_y <= 8 && to_y >= 1 && to_y <= 8) {
    const char* files = "?abcdefgh";
    const char* ranks = "?12345678";
    char move[5] = {files[from_x], ranks[from_y], files[to_x], ranks[to_y], 0};
    char piece = position.board[from_y][from_x];
    bool is_pawn = piece == 'p' || piece == 'P';
    bool to_last_rank = to_y == 1 || to_y == 8;
    if (is_pawn && to_last_rank) {
      // UCI requires explicitly tacking on a "q" for pawn promotion.
      move[4] = 'q';
      return std::string(move, 5);
    }
    return std::string(move, 4);
  }
  return "";
}
}

std::string eniac_chess_move(const std::string& fen) {
  Position position;
  if (!parse_fen(fen, position)) {
    return "";
  }
  Deck deck(convert_position_to_deck(position));
  int cur_card = 0;

  VM vm;
  init(&vm);
  while (!(vm.status & IO_PRINT)) {
    step_one_instruction(&vm);
    if (vm.error != 0) {
      return "";
    }
    if (vm.status & IO_READ) {
      if (cur_card > deck.size()) {
        return "";
      }
      auto [f, g] = deck[cur_card++];
      vm.f = f;
      vm.g = g;
      vm.h %= 10;
      vm.status &= ~IO_READ;
    }
  }

  return convert_move_to_lan(position, drop_sign(vm.a), vm.b);
}

#ifdef MAIN
int main() {
  // Read lines with FENs from stdin and write moves to stdout
  char* line = nullptr;
  size_t cap = 0;
  while (getline(&line, &cap, stdin) > 0) {
    std::string fen = std::string(line);
    std::string move = eniac_chess_move(fen);
    printf("%s\n", move.c_str());
    fflush(stdout);
  }
  free(line);
}
#endif
