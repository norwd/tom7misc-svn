
#ifndef _PLUGINVERT_NTSC2D_H
#define _PLUGINVERT_NTSC2D_H

#include <array>
#include <cstdint>
#include <tuple>

#include "image.h"

struct NTSC2D {
  struct RGB {
    uint8_t r, g, b;
  };

  // NES NTSC Palette, in RGB triplets.
  static constexpr std::array<RGB, 64>
  ntsc_palette = {
    RGB{0x80,0x80,0x80}, {0x00,0x3D,0xA6}, {0x00,0x12,0xB0}, {0x44,0x00,0x96},
    {0xA1,0x00,0x5E}, {0xC7,0x00,0x28}, {0xBA,0x06,0x00}, {0x8C,0x17,0x00},
    {0x5C,0x2F,0x00}, {0x10,0x45,0x00}, {0x05,0x4A,0x00}, {0x00,0x47,0x2E},
    {0x00,0x41,0x66}, {0x00,0x00,0x00}, {0x05,0x05,0x05}, {0x05,0x05,0x05},
    {0xC7,0xC7,0xC7}, {0x00,0x77,0xFF}, {0x21,0x55,0xFF}, {0x82,0x37,0xFA},
    {0xEB,0x2F,0xB5}, {0xFF,0x29,0x50}, {0xFF,0x22,0x00}, {0xD6,0x32,0x00},
    {0xC4,0x62,0x00}, {0x35,0x80,0x00}, {0x05,0x8F,0x00}, {0x00,0x8A,0x55},
    {0x00,0x99,0xCC}, {0x21,0x21,0x21}, {0x09,0x09,0x09}, {0x09,0x09,0x09},
    {0xFF,0xFF,0xFF}, {0x0F,0xD7,0xFF}, {0x69,0xA2,0xFF}, {0xD4,0x80,0xFF},
    {0xFF,0x45,0xF3}, {0xFF,0x61,0x8B}, {0xFF,0x88,0x33}, {0xFF,0x9C,0x12},
    {0xFA,0xBC,0x20}, {0x9F,0xE3,0x0E}, {0x2B,0xF0,0x35}, {0x0C,0xF0,0xA4},
    {0x05,0xFB,0xFF}, {0x5E,0x5E,0x5E}, {0x0D,0x0D,0x0D}, {0x0D,0x0D,0x0D},
    {0xFF,0xFF,0xFF}, {0xA6,0xFC,0xFF}, {0xB3,0xEC,0xFF}, {0xDA,0xAB,0xEB},
    {0xFF,0xA8,0xF9}, {0xFF,0xAB,0xB3}, {0xFF,0xD2,0xB0}, {0xFF,0xEF,0xA6},
    {0xFF,0xF7,0x9C}, {0xD7,0xE8,0x95}, {0xA6,0xED,0xAF}, {0xA2,0xF2,0xDA},
    {0x99,0xFF,0xFC}, {0xDD,0xDD,0xDD}, {0x11,0x11,0x11}, {0x11,0x11,0x11}
  };

  static constexpr std::array<uint8_t, 64> best_permutation = {
    0x0d, 0x0f, 0x2f, 0x2e, 0x0c, 0x03, 0x02, 0x13,
    0x0e, 0x1f, 0x3f, 0x1d, 0x04, 0x01, 0x11, 0x12,
    0x1e, 0x3e, 0x0b, 0x2d, 0x1c, 0x25, 0x14, 0x24,
    0x0a, 0x09, 0x08, 0x1b, 0x00, 0x10, 0x22, 0x23,
    0x06, 0x07, 0x05, 0x19, 0x35, 0x3d, 0x33, 0x34,
    0x17, 0x15, 0x18, 0x36, 0x3a, 0x3b, 0x32, 0x21,
    0x16, 0x26, 0x1a, 0x39, 0x37, 0x3c, 0x31, 0x2c,
    0x27, 0x28, 0x29, 0x2a, 0x38, 0x2b, 0x20, 0x30,
  };

  // Maps from 64 NES colors to a cell in [0,0] to [7,7].
  std::array<std::pair<int, int>, 64> idx_to_uv;
  ImageRGBA img;

  static constexpr int WIDTH = 8;
  static constexpr int HEIGHT = 8;
  NTSC2D() : img(WIDTH, HEIGHT) {
    // initialize idx_to_uv
    // Loop over cells in best_permutation.
    for (int i = 0; i < 64; i++) {
      int u = i % WIDTH;
      int v = i / WIDTH;

      int nes_idx = best_permutation[i];
      idx_to_uv[nes_idx] = std::make_pair(u, v);
    }

    // And fill image with pixels; bilinear sampling is easiest
    for (int y = 0; y < HEIGHT; y++) {
      for (int x = 0; x < WIDTH; x++) {
        int nes_idx = best_permutation[y * WIDTH + x];
        RGB color = ntsc_palette[nes_idx];
        img.SetPixel(x, y, color.r, color.g, color.b, 0xFF);
      }
    }
  }

  std::tuple<float, float> IndexToUV(int nes_idx) const {
    static constexpr float inv_width = 1.0f / (WIDTH - 1.0f);
    static constexpr float inv_height = 1.0f / (HEIGHT - 1.0f);
    auto [u, v] = idx_to_uv[nes_idx];
    // PERF could just be storing these predivided
    // use centers of pixels
    return std::make_tuple((u + 0.5f) * inv_width, (v + 0.5f) * inv_height);
  }

  std::tuple<uint8_t, uint8_t, uint8_t> UVColorSmooth(float u, float v) const {
    // SampleBilinear treats the pixel as being located at its
    // top-left corner. We shift the UV coordinates from the center of
    // the pixel to the top left to compensate.
    auto [r, g, b, a] = img.SampleBilinear(u * (WIDTH - 1.0f) - 0.5f,
                                           v * (HEIGHT - 1.0f) - 0.5f);
    auto Round8 = [](float f) -> uint8_t {
        if (f < 0.0f) return 0;
        if (f > 255.0f) return 255;
        return (uint8_t)std::roundf(f);
      };
    return std::make_tuple(Round8(r), Round8(g), Round8(b));
  }

  std::tuple<uint8_t, uint8_t, uint8_t> UVColorClosest(float u, float v) const {
    // Truncate to round down.
    int uu = u * (WIDTH - 1.0f);
    int vv = v * (HEIGHT - 1.0f);
    if (uu < 0 || vv < 0) return std::make_tuple(0, 0, 0);
    if (uu >= WIDTH || vv >= HEIGHT) return std::make_tuple(255, 255, 255);
    auto [r, g, b, a_] = img.GetPixel(uu, vv);
    return std::make_tuple(r, g, b);
  }

};

#endif
