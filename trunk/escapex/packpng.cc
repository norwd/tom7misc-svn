#include "../cc-lib/image.h"
#include "../cc-lib/util.h"
#include "../cc-lib/base/stringprintf.h"

#include <iostream>
#include <fstream>
#include <memory>
#include <cstring>
#include <chrono>

using namespace std;

constexpr bool VERBOSE = false;

// #define BACKCOLOR 0x33, 0x88, 0x33, 0xAA
#define BACKCOLOR 0x338833AA

/* smaller growrate gives slightly better output,
   with substantially worse performance */
#define GROWRATE 4

struct UsedMap {
  /* PERF could use less memory with a bit mask,
     but this program is run off-line, so that
     seems pretty pointless */
  char *arr = nullptr;
  int w = 0, h = 0;

  UsedMap(int ww, int hh) : w(ww), h(hh) {
    arr = (char*)malloc(ww * hh * sizeof(char));
    memset(arr, 0, ww * hh * sizeof (char));
  }

  /* new areas are unused */
  void Resize(int ww, int hh) {
    char *na = (char*)malloc(ww * hh * sizeof (char));

    /* start unused */
    memset(na, 0, ww * hh * sizeof (char));

    /* copy old used */
    for (int xx = 0; xx < w; xx++) {
      for (int yy = 0; yy < h; yy++) {
        if (Used(xx, yy) && xx < ww && yy < hh) {
          na[yy * ww + xx] = 1;
        }
      }
    }

    free(arr);
    arr = na;
    w = ww;
    h = hh;
  }

  bool Used(int x, int y) {
    return arr[x + y * w];
  }

  bool UsedRange(int x, int y, int ww, int hh) {
    for (int yy = 0; yy < hh; yy++) {
      for (int xx = 0; xx < ww; xx++) {
        if (Used(x + xx, y + yy)) return true;
      }
    }
    return false;
  }

  void Use(int x, int y) {
    arr[x + y * w] = 1;
  }

  void UseRange(int x, int y, int ww, int hh) {
    for (int yy = 0; yy < hh; yy++) {
      for (int xx = 0; xx < ww; xx++) {
        Use(x + xx, y + yy);
      }
    }
  }

  ~UsedMap() {
    free(arr);
  }
};

static std::pair<int, int> FitImage(UsedMap *um, int w, int h) {
  for (;;) {
    for (int yy = 0; yy <= um->h - h; yy++) {
      for (int xx = 0; xx <= um->w - w; xx++) {
        if (!um->UsedRange(xx, yy, w, h)) {
          um->UseRange(xx, yy, w, h);
          return make_pair(xx, yy);
        }
      }
    }

    /* didn't fit. expand to make the image more square. */
    /* PERF insane */
    int nw = um->w, nh = um->h;

    /* minimum sane sizes */
    if (um->w < w) {
      nw = w;
    } else if (um->h < h) {
      nh = h;
    } else if (um->w <= um->h) {
      nw = um->w + GROWRATE;
    } else {
      nh = um->h + GROWRATE;
    }

    um->Resize(nw, nh);

    if (VERBOSE) {
      printf("Resized to %dx%d\n", nw, nh);
    }
  }
}

struct PackResult {
  // Size of packed image.
  int width = 0, height = 0;
  // x, y, w, h
  map<string, tuple<int, int, int, int>> all_symbols;
};

static PackResult PackToImage(
    const vector<pair<string, unique_ptr<ImageRGBA>>> &to_pack) {
  std::unique_ptr<UsedMap> um(new UsedMap{1, 1});

  // x, y, w, h
  PackResult result;
  for (const auto &[name, pic] : to_pack) {
    /* find a place where it will fit. */
    const auto [x, y] =
      FitImage(um.get(), pic->Width(), pic->Height());

    if (VERBOSE)
      printf("%s at %d/%d\n", name.c_str(), x, y);

    CHECK(result.all_symbols.find(name) == result.all_symbols.end()) <<
      name << " appeared more than once";

    result.all_symbols[name] = make_tuple(x, y, pic->Width(), pic->Height());
  }

  result.width = um->w;
  result.height = um->h;
  return result;
}

int main(int argc, char **argv) {

  // XXX probably not useful for this app?
  /* change to location of binary, so that we can find the
     images needed. */
  if (argc > 0) {
    string wd = Util::pathof(argv[0]);
    Util::changedir(wd);
  }

  if (argc != 3) {
    printf("\n"
           "Usage: packpng description.pack basename\n");
    printf("Creates a packed PNG graphic from each of the files in\n"
           "description.pack. Produces:\n"
           "   basename.png    (graphics)\n"
           "   basename_defs.h (defines the members as Basename::pic)\n"
           "   basename_syms.h (just the symbols, comma-separated)\n"
           "   basename_copy.h (copies the surfaces from packed ImageRGBA)\n"
           "\n"
           "See packpng.cc for details.\n\n");
    return 1;
  }

  auto time_start = std::chrono::steady_clock::now();

  string descname = argv[1];
  string basename = argv[2];
  if (basename.empty() || !(basename[0] >= 'a' && basename[0] <= 'z')) {
    printf("Basename must start with a lowercase letter!\n");
    return 1;
  }

  const string generated_comment =
    StringPrintf("/* Generated by packpng from %s. DO NOT EDIT! */\n",
                 descname.c_str());

  printf("Packpng %s %s...\n", descname.c_str(), basename.c_str());

  // XXX get this from the pack file?
  string classname = basename;
  // Make its first letter uppercase.
  classname[0] &= ~32;


  /* XXX we should make this part much smarter once
     we have a lot of animation frames or graphics of
     different sizes. The problem is probably NP hard
     in general but we can still do a better job with
     some greedy packing algorithm (keep a bit mask of
     'used' areas of the graphic) */

  /* now a single pass, resizing the destination image
     as needed. */

  std::vector<std::pair<string, std::unique_ptr<ImageRGBA>>> to_pack;
  {
    ifstream desc(descname.c_str());
    string name, file;
    while (desc >> name >> file) {
      std::unique_ptr<ImageRGBA> pic(ImageRGBA::Load(file));

      if (!pic.get()) {
        printf("Packpng error! Can't open image file '%s'\n",
               file.c_str());
        exit(-1);
      }
      to_pack.emplace_back(std::move(name), std::move(pic));
    }
  }

  PackResult pack_result = PackToImage(to_pack);
  const auto &all_symbols = pack_result.all_symbols;

  // Create image.
  ImageRGBA packed(pack_result.width, pack_result.height);
  packed.Clear32(BACKCOLOR);

  {
    std::unordered_map<string, std::unique_ptr<ImageRGBA>> pics;
    for (auto &[sym, pic] : to_pack)
      pics[sym] = std::move(pic);
    to_pack.clear();

    for (const auto &[sym, xywh] : pack_result.all_symbols) {
      const auto [x, y, w, h] = xywh;

      auto it = pics.find(sym);
      CHECK(it != pics.end()) << "bug? " << sym;
      const auto &pic = it->second;

      packed.CopyImage(x, y, *pic);
    }
  }

  // New (2021) via graphics.h.

  // This is just a comma-separated list of the symbols.
  // Can be used like:
  //   using SDL_SurfacePtr = SDL_Surface *;
  //   SDL_SurfacePtr
  //   #include "animation_syms.h"
  //   ;
  vector<string> syms;
  for (const auto &[sym, pos_] : all_symbols) syms.push_back(sym);
  {
    string syms_contents = generated_comment;
    syms_contents += Util::Join(syms, ", ");
    Util::WriteFile(StringPrintf("%s_syms.h", basename.c_str()),
                    syms_contents);
  }

  {
    string decs_contents = generated_comment;
    for (const string &sym : syms) {
      StringAppendF(&decs_contents,
                    "SDL_Surface *%s::%s;\n",
                    classname.c_str(), sym.c_str());
    }
    Util::WriteFile(StringPrintf("%s_decs.h", basename.c_str()),
                    decs_contents);
  }

  {
    string init_contents = generated_comment;
    for (const auto &[sym, pos] : all_symbols) {
      const auto [x, y, w, h] = pos;
      StringAppendF(&init_contents,
                    "%s = all.Crop32(%d, %d, %d, %d);\n",
                    sym.c_str(), x, y, w, h);
    }
    Util::WriteFile(StringPrintf("%s_init.h", basename.c_str()),
                    init_contents);
  }

  {
    string copy_contents = generated_comment;
    for (const auto &[sym, pos_] : all_symbols) {
      StringAppendF(&copy_contents,
                    "%s = sdlutil::FromRGBA(graphics.%s);\n"
                    "if (%s == nullptr) return false;\n",
                    sym.c_str(), sym.c_str(),
                    sym.c_str());
    }
    Util::WriteFile(StringPrintf("%s_copy.h", basename.c_str()),
                    copy_contents);
  }

  if (VERBOSE) {
    printf("Saving...\n");
    fflush(stdout);
  }

  const string pngfile = basename + ".png";
  if (!packed.Save(pngfile)) {
    printf("Couldn't write output PNG to %s.\n", pngfile.c_str());
    return -1;
  }

  auto time_end = std::chrono::steady_clock::now();
  std::chrono::duration<double> time_elapsed = time_end - time_start;

  printf("Done in %.3fs!\n", time_elapsed.count());

  return 0;
}
