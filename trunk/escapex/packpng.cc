
#include <iostream>
#include <fstream>
#include <memory>
#include <cstring>
#include <chrono>

#include "../cc-lib/image.h"
#include "../cc-lib/util.h"
#include "../cc-lib/base/stringprintf.h"
#include "../cc-lib/packrect.h"

using namespace std;

constexpr bool VERBOSE = false;

// #define BACKCOLOR 0x33, 0x88, 0x33, 0xAA
#define BACKCOLOR 0x338833AA

struct PackResult {
  // Size of packed image.
  int width = 0, height = 0;
  // x, y, w, h
  map<string, tuple<int, int, int, int>> all_symbols;
};

static PackResult PackToImage(
    const vector<pair<string, unique_ptr<ImageRGBA>>> &to_pack) {
  PackRect::Config config;
  config.budget_passes = 10000;

  std::vector<std::pair<int, int>> rects;
  rects.reserve(to_pack.size());
  for (const auto &[sym_, img] : to_pack)
    rects.emplace_back(img->Width(), img->Height());

  PackResult result;
  std::vector<std::pair<int, int>> positions;
  CHECK(PackRect::Pack(config,
                       rects,
                       &result.width, &result.height,
                       &positions)) << "Should succeed on unconstrained "
    "problem!";

  CHECK_EQ(positions.size(), to_pack.size());
  for (int i = 0; i < to_pack.size(); i++) {
    const auto &[sym, pic] = to_pack[i];
    const auto [x, y] = positions[i];
    result.all_symbols[sym] = make_tuple(x, y,
                                         pic->Width(), pic->Height());
  }
  return result;
}


int main(int argc, char **argv) {

  // XXX probably not useful for this app?
  /* change to location of binary, so that we can find the
     images needed. */
  if (argc > 0) {
    string wd = Util::pathof(argv[0]);
    Util::changedir(wd);
  }

  if (argc != 3) {
    printf("\n"
           "Usage: packpng description.pack basename\n");
    printf("Creates a packed PNG graphic from each of the files in\n"
           "description.pack. Produces:\n"
           "   basename.png    (graphics)\n"
           "   basename_defs.h (defines the members as Basename::pic)\n"
           "   basename_syms.h (just the symbols, comma-separated)\n"
           "   basename_copy.h (copies the surfaces from packed ImageRGBA)\n"
           "\n"
           "See packpng.cc for details.\n\n");
    return 1;
  }

  auto time_start = std::chrono::steady_clock::now();

  string descname = argv[1];
  string basename = argv[2];
  if (basename.empty() || !(basename[0] >= 'a' && basename[0] <= 'z')) {
    printf("Basename must start with a lowercase letter!\n");
    return 1;
  }

  const string generated_comment =
    StringPrintf("/* Generated by packpng from %s. DO NOT EDIT! */\n",
                 descname.c_str());

  printf("Packpng %s %s...\n", descname.c_str(), basename.c_str());

  // XXX get this from the pack file?
  string classname = basename;
  // Make its first letter uppercase.
  classname[0] &= ~32;


  /* XXX we should make this part much smarter once
     we have a lot of animation frames or graphics of
     different sizes. The problem is probably NP hard
     in general but we can still do a better job with
     some greedy packing algorithm (keep a bit mask of
     'used' areas of the graphic) */

  /* now a single pass, resizing the destination image
     as needed. */

  std::vector<std::pair<string, std::unique_ptr<ImageRGBA>>> to_pack;
  {
    ifstream desc(descname.c_str());
    string name, file;
    while (desc >> name >> file) {
      std::unique_ptr<ImageRGBA> pic(ImageRGBA::Load(file));

      if (!pic.get()) {
        printf("Packpng error! Can't open image file '%s'\n",
               file.c_str());
        exit(-1);
      }
      to_pack.emplace_back(std::move(name), std::move(pic));
    }
  }

  PackResult pack_result = PackToImage(to_pack);
  const auto &all_symbols = pack_result.all_symbols;

  // Create image.
  ImageRGBA packed(pack_result.width, pack_result.height);
  packed.Clear32(BACKCOLOR);

  {
    std::unordered_map<string, std::unique_ptr<ImageRGBA>> pics;
    for (auto &[sym, pic] : to_pack)
      pics[sym] = std::move(pic);
    to_pack.clear();

    for (const auto &[sym, xywh] : pack_result.all_symbols) {
      const auto [x, y, w, h] = xywh;

      auto it = pics.find(sym);
      CHECK(it != pics.end()) << "bug? " << sym;
      const auto &pic = it->second;

      packed.CopyImage(x, y, *pic);
    }
  }

  // New (2021) via graphics.h.

  // This is just a comma-separated list of the symbols.
  // Can be used like:
  //   using SDL_SurfacePtr = SDL_Surface *;
  //   SDL_SurfacePtr
  //   #include "animation_syms.h"
  //   ;
  vector<string> syms;
  for (const auto &[sym, pos_] : all_symbols) syms.push_back(sym);
  {
    string syms_contents = generated_comment;
    syms_contents += Util::Join(syms, ", ");
    Util::WriteFile(StringPrintf("%s_syms.h", basename.c_str()),
                    syms_contents);
  }

  {
    string decs_contents = generated_comment;
    for (const string &sym : syms) {
      StringAppendF(&decs_contents,
                    "SDL_Surface *%s::%s;\n",
                    classname.c_str(), sym.c_str());
    }
    Util::WriteFile(StringPrintf("%s_decs.h", basename.c_str()),
                    decs_contents);
  }

  {
    string init_contents = generated_comment;
    for (const auto &[sym, pos] : all_symbols) {
      const auto [x, y, w, h] = pos;
      StringAppendF(&init_contents,
                    "%s = all.Crop32(%d, %d, %d, %d);\n",
                    sym.c_str(), x, y, w, h);
    }
    Util::WriteFile(StringPrintf("%s_init.h", basename.c_str()),
                    init_contents);
  }

  {
    string copy_contents = generated_comment;
    for (const auto &[sym, pos_] : all_symbols) {
      StringAppendF(&copy_contents,
                    "%s = sdlutil::FromRGBA(graphics.%s);\n"
                    "if (%s == nullptr) return false;\n",
                    sym.c_str(), sym.c_str(),
                    sym.c_str());
    }
    Util::WriteFile(StringPrintf("%s_copy.h", basename.c_str()),
                    copy_contents);
  }

  if (VERBOSE) {
    printf("Saving...\n");
    fflush(stdout);
  }

  const string pngfile = basename + ".png";
  if (!packed.Save(pngfile)) {
    printf("Couldn't write output PNG to %s.\n", pngfile.c_str());
    return -1;
  }

  auto time_end = std::chrono::steady_clock::now();
  std::chrono::duration<double> time_elapsed = time_end - time_start;

  printf("Done in %.3fs! Size %d x %d\n",
         time_elapsed.count(),
         packed.Width(), packed.Height());

  return 0;
}
